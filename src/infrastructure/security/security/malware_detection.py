"""
恶意代码检测器 - 静态代码分析、模式匹配和行为分析
提供恶意代码检测、特征码匹配和启发式分析功能
"""

import ast
import re
import hashlib
import logging
from typing import Dict, List, Set, Tuple, Optional, Any
from dataclasses import dataclass, field
from enum import Enum
import importlib.util
import sys

logger = logging.getLogger(__name__)


class ThreatLevel(Enum):
    """威胁等级"""
    SAFE = ("safe", 0)
    LOW = ("low", 1)
    MEDIUM = ("medium", 2)
    HIGH = ("high", 3)
    CRITICAL = ("critical", 4)

    def __init__(self, name, level):
        self._name = name
        self._level = level

    @property
    def level(self):
        return self._level

    def __lt__(self, other):
        if self.__class__ is other.__class__:
            return self._level < other._level
        return NotImplemented

    def __le__(self, other):
        if self.__class__ is other.__class__:
            return self._level <= other._level
        return NotImplemented

    def __gt__(self, other):
        if self.__class__ is other.__class__:
            return self._level > other._level
        return NotImplemented

    def __ge__(self, other):
        if self.__class__ is other.__class__:
            return self._level >= other._level
        return NotImplemented


class ThreatType(Enum):
    """威胁类型"""
    COMMAND_INJECTION = "command_injection"
    FILE_OPERATION = "file_operation"
    NETWORK_ACCESS = "network_access"
    SYSTEM_CALL = "system_call"
    CODE_INJECTION = "code_injection"
    PRIVILEGE_ESCALATION = "privilege_escalation"
    ENCRYPTION = "encryption"
    NETWORK_SCAN = "network_scan"
    DYNAMIC_CODE_EXEC = "dynamic_code_exec"
    UNAUTHORIZED_ACCESS = "unauthorized_access"
    DATA_EXFILTRATION = "data_exfiltration"


@dataclass
class SecurityPattern:
    """安全模式"""
    name: str
    pattern: str
    threat_type: ThreatType
    threat_level: ThreatLevel
    description: str
    regex: Optional[re.Pattern] = None
    ast_check: Optional[callable] = None

    def __post_init__(self):
        if not self.regex and self.pattern:
            self.regex = re.compile(self.pattern, re.IGNORECASE | re.MULTILINE)


@dataclass
class DetectionResult:
    """检测结果"""
    is_malicious: bool
    threat_level: ThreatLevel
    matched_patterns: List[Tuple[str, int, int]]  # (pattern_name, start, end)
    details: Dict[str, Any] = field(default_factory=dict)
    scan_time: float = 0


class StaticAnalyzer:
    """静态代码分析器"""

    def __init__(self):
        self.dangerous_functions = {
            # 命令执行
            'os.system', 'subprocess.call', 'subprocess.run', 'subprocess.Popen',
            'subprocess.check_call', 'subprocess.check_output', 'exec', 'eval',
            'commands.getoutput', 'commands.getstatusoutput',
            # 文件操作
            'open', 'execfile', '__import__',
            # 网络操作
            'urllib.request.urlopen', 'urllib.request.urlretrieve',
            'urllib.urlopen', 'urllib.urlretrieve',
            'requests.get', 'requests.post', 'requests.put', 'requests.delete',
            # 系统操作
            'os.popen', 'os.spawn', 'os.exec', 'osexecl', 'execl',
            # 加密
            'crypt', 'hashlib.md5', 'hashlib.sha1', 'hashlib.sha256',
            'Crypto.Cipher', 'pycrypto', 'base64.b64encode', 'base64.b64decode',
            # 反调试
            'sys.settrace', 'sys.gettrace',
            # 反射
            'getattr', 'setattr', 'delattr', 'hasattr', 'vars', 'dir',
        }

    def analyze_ast(self, code: str) -> List[Tuple[str, int, Dict[str, Any]]]:
        """分析AST"""
        issues = []

        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            return [("SYNTAX_ERROR", e.lineno, {"message": str(e)})]

        # 分析AST节点
        for node in ast.walk(tree):
            # 检查危险函数调用
            if isinstance(node, ast.Call):
                issues.extend(self._check_function_call(node, tree))

            # 检查动态代码执行
            if isinstance(node, (ast.Expr,)) and hasattr(node, 'value'):
                if isinstance(node.value, (ast.Call,)) and hasattr(node.value.func, 'id'):
                    if node.value.func.id in ['eval', 'exec', 'compile']:
                        issues.append(("DYNAMIC_CODE_EXEC", node.lineno, {}))

            # 检查导入操作
            if isinstance(node, ast.Import):
                for alias in node.names:
                    if alias.name in self.dangerous_functions:
                        issues.append(("DANGEROUS_IMPORT", node.lineno, {
                            "import": alias.name,
                            "alias": alias.asname
                        }))

            if isinstance(node, ast.ImportFrom):
                if node.module:
                    full_name = f"{node.module}.{node.names[0].name}" if node.names else node.module
                    if full_name in self.dangerous_functions:
                        issues.append(("DANGEROUS_IMPORT", node.lineno, {
                            "module": node.module,
                            "names": [n.name for n in node.names]
                        }))

            # 检查exec语句 (Python 3.13移除了ast.Exec)
            # if isinstance(node, ast.Exec):
            #     issues.append(("EXEC_STATEMENT", node.lineno, {}))

        return issues

    def _check_function_call(self, node: ast.Call, tree: ast.AST) -> List[Tuple[str, int, Dict[str, Any]]]:
        """检查函数调用"""
        issues = []

        # 获取函数名
        if isinstance(node.func, ast.Name):
            func_name = node.func.id
        elif isinstance(node.func, ast.Attribute):
            # 处理 attribute.func (e.g., os.system)
            if isinstance(node.func.value, ast.Name):
                func_name = f"{node.func.value.id}.{node.func.attr}"
            else:
                func_name = node.func.attr
        else:
            func_name = "unknown"

        # 检查是否为危险函数
        if func_name in self.dangerous_functions:
            issues.append(("DANGEROUS_FUNCTION_CALL", node.lineno, {
                "function": func_name,
                "args_count": len(node.args)
            }))

        # 检查eval调用
        if func_name == "eval":
            issues.append(("EVAL_CALL", node.lineno, {
                "risk": "Dynamic code execution"
            }))

        # 检查exec调用
        if func_name == "exec":
            issues.append(("EXEC_CALL", node.lineno, {
                "risk": "Dynamic code execution"
            }))

        # 检查__import__调用
        if func_name == "__import__":
            if node.args and isinstance(node.args[0], ast.Constant):
                module_name = node.args[0].value
                if module_name in ['os', 'subprocess', 'socket', 'pickle', 'marshal']:
                    issues.append(("DYNAMIC_IMPORT", node.lineno, {
                        "module": module_name
                    }))

        # 检查pickle.load和marshal.load
        if func_name in ['pickle.load', 'pickle.loads', 'marshal.load', 'marshal.loads']:
            issues.append(("DESERIALIZATION", node.lineno, {
                "function": func_name,
                "risk": "Arbitrary code execution via deserialization"
            }))

        return issues


class PatternMatcher:
    """模式匹配器"""

    def __init__(self):
        self.patterns = self._load_patterns()

    def _load_patterns(self) -> List[SecurityPattern]:
        """加载安全模式"""
        patterns = [
            # 命令注入模式
            SecurityPattern(
                name="CommandInjection",
                pattern=r"(os\.system|subprocess\.(call|run|Popen|check_call|check_output|getoutput))\s*\(",
                threat_type=ThreatType.COMMAND_INJECTION,
                threat_level=ThreatLevel.HIGH,
                description="Command injection vulnerability"
            ),
            SecurityPattern(
                name="ShellCommand",
                pattern=r"shell\s*=\s*['\"].*;.*['\"]",
                threat_type=ThreatType.COMMAND_INJECTION,
                threat_level=ThreatLevel.MEDIUM,
                description="Shell command construction"
            ),

            # 文件操作模式
            SecurityPattern(
                name="FileWrite",
                pattern=r"open\s*\(\s*['\"].*\.(exe|bat|sh|dll|so|pdf|doc|docx).*['\"]",
                threat_type=ThreatType.FILE_OPERATION,
                threat_level=ThreatLevel.MEDIUM,
                description="Writing executable file"
            ),
            SecurityPattern(
                name="SymlinkAttack",
                pattern=r"os\.(symlink|link|mkdir|makedirs)\s*\(",
                threat_type=ThreatType.FILE_OPERATION,
                threat_level=ThreatLevel.HIGH,
                description="File system manipulation"
            ),

            # 网络访问模式
            SecurityPattern(
                name="NetworkConnection",
                pattern=r"(urllib\.request\.urlopen|requests\.(get|post|put|delete))",
                threat_type=ThreatType.NETWORK_ACCESS,
                threat_level=ThreatLevel.MEDIUM,
                description="Network connection"
            ),
            SecurityPattern(
                name="SocketConnection",
                pattern=r"socket\.(socket|connect|bind|listen|accept)",
                threat_type=ThreatType.NETWORK_ACCESS,
                threat_level=ThreatLevel.MEDIUM,
                description="Socket connection"
            ),

            # 系统调用模式
            SecurityPattern(
                name="SystemCall",
                pattern=r"os\.(popen|spawn|exec|execl)",
                threat_type=ThreatType.SYSTEM_CALL,
                threat_level=ThreatLevel.HIGH,
                description="System call"
            ),

            # 动态代码执行
            SecurityPattern(
                name="EvalCall",
                pattern=r"eval\s*\(",
                threat_type=ThreatType.DYNAMIC_CODE_EXEC,
                threat_level=ThreatLevel.CRITICAL,
                description="eval() call - allows arbitrary code execution"
            ),
            SecurityPattern(
                name="ExecCall",
                pattern=r"exec\s*\(",
                threat_type=ThreatType.DYNAMIC_CODE_EXEC,
                threat_level=ThreatLevel.CRITICAL,
                description="exec() call - allows arbitrary code execution"
            ),
            SecurityPattern(
                name="CompileCall",
                pattern=r"compile\s*\(",
                threat_type=ThreatType.DYNAMIC_CODE_EXEC,
                threat_level=ThreatLevel.HIGH,
                description="compile() call - dynamic code compilation"
            ),

            # 加密操作
            SecurityPattern(
                name="Encryption",
                pattern=r"(Crypto|pycrypto|cryptography|AES|RSA|SHA|md5|sha1|sha256)",
                threat_type=ThreatType.ENCRYPTION,
                threat_level=ThreatLevel.MEDIUM,
                description="Encryption operation"
            ),
            SecurityPattern(
                name="Base64Encode",
                pattern=r"base64\.(b64encode|b64decode|encode|decode)",
                threat_type=ThreatType.ENCRYPTION,
                threat_level=ThreatLevel.MEDIUM,
                description="Base64 encoding/decoding"
            ),

            # 反射/内省
            SecurityPattern(
                name="Reflection",
                pattern=r"(getattr|setattr|delattr|hasattr|vars|dir|inspect\.)",
                threat_type=ThreatType.DYNAMIC_CODE_EXEC,
                threat_level=ThreatLevel.MEDIUM,
                description="Object introspection"
            ),

            # 反调试技术
            SecurityPattern(
                name="AntiDebug",
                pattern=r"sys\.settrace|gettrace",
                threat_type=ThreatType.SYSTEM_CALL,
                threat_level=ThreatLevel.HIGH,
                description="Anti-debugging technique"
            ),

            # 反序列化
            SecurityPattern(
                name="Deserialization",
                pattern=r"(pickle\.(load|loads|marshal\.(load|loads)))",
                threat_type=ThreatType.CODE_INJECTION,
                threat_level=ThreatLevel.CRITICAL,
                description="Object deserialization - can execute arbitrary code"
            ),

            # 网络扫描模式
            SecurityPattern(
                name="PortScan",
                pattern=r"for\s+\w+\s+in\s+range\(\s*\d+\s*,\s*\d+\s*\)\s*:.*socket\.connect",
                threat_type=ThreatType.NETWORK_SCAN,
                threat_level=ThreatLevel.HIGH,
                description="Port scanning pattern"
            ),

            # 数据渗漏
            SecurityPattern(
                name="DataExfiltration",
                pattern=r"(send|sendto|sendall)\s*\(",
                threat_type=ThreatType.DATA_EXFILTRATION,
                threat_level=ThreatLevel.HIGH,
                description="Data transmission pattern"
            ),
        ]

        return patterns

    def match_patterns(self, code: str) -> List[Tuple[str, int, int]]:
        """匹配模式"""
        matches = []

        for pattern in self.patterns:
            for match in pattern.regex.finditer(code):
                matches.append((pattern.name, match.start(), match.end()))

        return matches


class BehaviorAnalyzer:
    """行为分析器"""

    def __init__(self):
        self.suspicious_patterns = {
            'code_obfuscation': [
                r'__import__\(.*\)',
                r'exec\(compile\(',
                r'base64\.(b64decode|decode)',
                r'chr\(.*\)\.join',
                r'\[x for x in .*\]',
            ],
            'anti_analysis': [
                r'sys\.settrace',
                r'time\.sleep\(.*\)',
                r'random\.randint',
                r'del \w+',
            ],
            'persistence': [
                r'os\.chmod',
                r'setuid',
                r'setgid',
                r'cron',
                r'systemd',
            ],
            'privilege_escalation': [
                r'sudo',
                r'chmod \+s',
                r'setuid',
                r'cap_set',
            ]
        }

    def analyze_behavior(self, code: str) -> Dict[str, List[int]]:
        """分析行为模式"""
        results = {}

        for behavior_type, patterns in self.suspicious_patterns.items():
            matches = []
            for pattern in patterns:
                compiled = re.compile(pattern, re.IGNORECASE | re.MULTILINE)
                for match in compiled.finditer(code):
                    matches.append(match.start())
            results[behavior_type] = matches

        return results


class HeuristicEngine:
    """启发式分析引擎"""

    def __init__(self):
        self.heuristics = [
            {
                'name': 'high_entropy',
                'description': 'Code has high entropy - possibly obfuscated',
                'check': self._check_entropy
            },
            {
                'name': 'string_concatenation',
                'description': 'Extensive string concatenation - possible obfuscation',
                'check': self._check_string_concatenation
            },
            {
                'name': 'dynamic_execution',
                'description': 'Dynamic code execution detected',
                'check': self._check_dynamic_execution
            },
            {
                'name': 'file_system_manipulation',
                'description': 'Extensive file system manipulation',
                'check': self._check_file_manipulation
            },
            {
                'name': 'network_activity',
                'description': 'Network activity patterns',
                'check': self._check_network_activity
            }
        ]

    def _check_entropy(self, code: str, ast_issues: List) -> bool:
        """检查代码熵值"""
        import math
        # 计算字符串的熵
        strings = re.findall(r"['\"]([^'\"]*)['\"]", code)
        if not strings:
            return False

        entropy_scores = []
        for s in strings:
            if len(s) < 10:
                continue

            # 计算字符频率
            char_count = {}
            for char in s:
                char_count[char] = char_count.get(char, 0) + 1

            # 计算熵
            entropy = 0
            length = len(s)
            for count in char_count.values():
                prob = count / length
                if prob > 0:
                    entropy -= prob * math.log2(prob)

            entropy_scores.append(entropy)

        return max(entropy_scores) > 4.5 if entropy_scores else False

    def _check_string_concatenation(self, code: str, ast_issues: List) -> bool:
        """检查字符串拼接"""
        # 检查是否有多行字符串拼接
        join_pattern = r"['\"]\s*\+\s*['\"]"
        matches = len(re.findall(join_pattern, code))
        return matches > 10

    def _check_dynamic_execution(self, code: str, ast_issues: List) -> bool:
        """检查动态执行"""
        return any(issue[0] in ["EVAL_CALL", "EXEC_CALL", "DYNAMIC_CODE_EXEC"] for issue in ast_issues)

    def _check_file_manipulation(self, code: str, ast_issues: List) -> bool:
        """检查文件操作"""
        return any("file" in issue[0].lower() or "file" in str(issue[2]) for issue in ast_issues)

    def _check_network_activity(self, code: str, ast_issues: List) -> bool:
        """检查网络活动"""
        return any("network" in issue[0].lower() or "url" in str(issue[2]) for issue in ast_issues)

    def run_heuristics(self, code: str, ast_issues: List[Tuple[str, int, Dict]]) -> List[str]:
        """运行启发式分析"""
        triggered = []
        for heuristic in self.heuristics:
            try:
                if heuristic['check'](code, ast_issues):
                    triggered.append(heuristic['name'])
            except Exception as e:
                logger.error(f"Heuristic {heuristic['name']} failed: {e}")

        return triggered


class MalwareDetector:
    """恶意代码检测主类"""

    def __init__(self):
        self.static_analyzer = StaticAnalyzer()
        self.pattern_matcher = PatternMatcher()
        self.behavior_analyzer = BehaviorAnalyzer()
        self.heuristic_engine = HeuristicEngine()
        self.scan_count = 0
        self.threat_count = 0

    def scan_code(self, code: str, filename: str = "unknown") -> DetectionResult:
        """扫描代码"""
        import time
        start_time = time.time()

        self.scan_count += 1

        # 1. 静态分析
        ast_issues = self.static_analyzer.analyze_ast(code)

        # 2. 模式匹配
        pattern_matches = self.pattern_matcher.match_patterns(code)

        # 3. 行为分析
        behavior_issues = self.behavior_analyzer.analyze_behavior(code)

        # 4. 启发式分析
        heuristic_triggers = self.heuristic_engine.run_heuristics(code, ast_issues)

        # 5. 评估威胁等级
        is_malicious, threat_level = self._assess_threat(
            ast_issues, pattern_matches, behavior_issues, heuristic_triggers
        )

        if is_malicious:
            self.threat_count += 1

        scan_time = time.time() - start_time

        return DetectionResult(
            is_malicious=is_malicious,
            threat_level=threat_level,
            matched_patterns=[m[0] for m in pattern_matches],
            details={
                'filename': filename,
                'ast_issues': ast_issues,
                'pattern_matches': [(m[0], m[1], m[2]) for m in pattern_matches],
                'behavior_issues': behavior_issues,
                'heuristic_triggers': heuristic_triggers,
            },
            scan_time=scan_time
        )

    def _assess_threat(
        self,
        ast_issues: List,
        pattern_matches: List,
        behavior_issues: Dict,
        heuristic_triggers: List
    ) -> Tuple[bool, ThreatLevel]:
        """评估威胁等级"""
        critical_patterns = {"EVAL_CALL", "EXEC_CALL", "DESERIALIZATION", "CommandInjection"}
        high_patterns = {"DANGEROUS_FUNCTION_CALL", "SystemCall", "AntiDebug", "PortScan"}

        max_threat = ThreatLevel.SAFE

        # 检查AST问题
        for issue in ast_issues:
            if issue[0] in critical_patterns:
                max_threat = ThreatLevel(max(ThreatLevel.CRITICAL, max_threat))
            elif issue[0] in high_patterns:
                max_threat = ThreatLevel(max(ThreatLevel.HIGH, max_threat))
            elif "DANGEROUS" in issue[0] or "EXEC" in issue[0]:
                max_threat = ThreatLevel(max(ThreatLevel.MEDIUM, max_threat))

        # 检查模式匹配
        for pattern_name, _, _ in pattern_matches:
            if pattern_name in ["EvalCall", "ExecCall", "Deserialization"]:
                max_threat = ThreatLevel(max(ThreatLevel.CRITICAL, max_threat))
            elif pattern_name in ["CommandInjection", "SystemCall", "PortScan"]:
                max_threat = ThreatLevel(max(ThreatLevel.HIGH, max_threat))
            elif pattern_name in ["NetworkConnection", "FileWrite"]:
                max_threat = ThreatLevel(max(ThreatLevel.MEDIUM, max_threat))

        # 检查行为问题
        if behavior_issues:
            if behavior_issues.get('code_obfuscation'):
                max_threat = ThreatLevel(max(ThreatLevel.MEDIUM, max_threat))
            if behavior_issues.get('anti_analysis'):
                max_threat = ThreatLevel(max(ThreatLevel.HIGH, max_threat))

        # 检查启发式触发
        if heuristic_triggers:
            max_threat = ThreatLevel(max(ThreatLevel.MEDIUM, max_threat))

        return max_threat != ThreatLevel.SAFE, max_threat

    def scan_file(self, filepath: str) -> DetectionResult:
        """扫描文件"""
        try:
            with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                code = f.read()
            return self.scan_code(code, filepath)
        except Exception as e:
            logger.error(f"Failed to scan file {filepath}: {e}")
            return DetectionResult(
                is_malicious=True,
                threat_level=ThreatLevel.HIGH,
                matched_patterns=[],
                details={'error': str(e)}
            )

    def get_scan_stats(self) -> Dict[str, Any]:
        """获取扫描统计"""
        return {
            'total_scans': self.scan_count,
            'threats_detected': self.threat_count,
            'threat_rate': self.threat_count / self.scan_count if self.scan_count > 0 else 0
        }

    def add_custom_pattern(self, pattern: SecurityPattern):
        """添加自定义模式"""
        self.pattern_matcher.patterns.append(pattern)
        logger.info(f"Added custom pattern: {pattern.name}")

    def load_patterns_from_file(self, filepath: str):
        """从文件加载模式"""
        import json
        try:
            with open(filepath, 'r') as f:
                patterns_data = json.load(f)

            for pattern_data in patterns_data:
                pattern = SecurityPattern(
                    name=pattern_data['name'],
                    pattern=pattern_data['pattern'],
                    threat_type=ThreatType(pattern_data['threat_type']),
                    threat_level=ThreatLevel(pattern_data['threat_level']),
                    description=pattern_data['description']
                )
                self.add_custom_pattern(pattern)

            logger.info(f"Loaded {len(patterns_data)} patterns from {filepath}")
        except Exception as e:
            logger.error(f"Failed to load patterns: {e}")
