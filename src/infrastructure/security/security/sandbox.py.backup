"""
增強沙箱 - 安全的代碼執行環境
提供強化的資源限制和代碼監控
"""

import sys
import os
import signal
import logging
import time
import threading
from typing import Dict, Any, Optional, Callable
from dataclasses import dataclass

# 平台特定的resource模組
try:
    import resource
except ImportError:
    # Windows不支持resource模組
    resource = None

logger = logging.getLogger(__name__)


@dataclass
class ResourceLimits:
    """資源限制配置"""
    max_cpu_time: float = 5.0  # CPU時間限制（秒）
    max_wall_time: float = 10.0  # 牆面時間限制（秒）
    max_memory: int = 256 * 1024 * 1024  # 內存限制（字節）
    max_open_files: int = 100  # 打開文件數限制
    max_processes: int = 1  # 進程數限制


class TimeoutError(Exception):
    """超時異常"""
    pass


class ResourceExceededError(Exception):
    """資源超限異常"""
    pass


class SecureSandbox:
    """安全沙箱 - 嚴格控制代碼執行"""

    def __init__(self, limits: Optional[ResourceLimits] = None):
        self.limits = limits or ResourceLimits()
        self.monitoring_enabled = True
        self.execution_history: list = []

    def execute(
        self,
        code: str,
        timeout: float = 5.0,
        memory_limit_mb: int = 256
    ) -> Dict[str, Any]:
        """
        在沙箱中安全執行代碼

        Args:
            code: 待執行代碼
            timeout: 超時時間（秒）
            memory_limit_mb: 內存限制（MB）

        Returns:
            執行結果字典
        """
        result = {
            'success': False,
            'output': None,
            'error': None,
            'execution_time': 0,
            'memory_usage': 0,
            'timestamp': time.time()
        }

        start_time = time.time()

        # 設置信號處理器
        def timeout_handler(signum, frame):
            raise TimeoutError("Execution timeout")

        old_handler = signal.signal(signal.SIGALRM, timeout_handler)
        signal.alarm(int(timeout))

        try:
            # 設置資源限制
            self._set_resource_limits(timeout, memory_limit_mb)

            # 創建隔離環境
            safe_globals = self._create_safe_globals()
            safe_locals = {}

            # 編譯代碼
            compiled = compile(code, '<sandbox>', 'exec')

            # 執行代碼
            exec(compiled, safe_globals, safe_locals)

            result['success'] = True
            result['output'] = safe_locals

        except TimeoutError as e:
            result['error'] = str(e)
            logger.warning(f"Code execution timeout: {e}")
        except MemoryError:
            result['error'] = "Memory limit exceeded"
            logger.warning("Code execution exceeded memory limit")
        except Exception as e:
            result['error'] = str(e)
            logger.error(f"Code execution error: {e}")
        finally:
            # 恢復信號處理器
            signal.alarm(0)
            signal.signal(signal.SIGALRM, old_handler)

            # 記錄執行歷史
            result['execution_time'] = time.time() - start_time
            self.execution_history.append(result)

        return result

    def _set_resource_limits(self, timeout: float, memory_mb: int):
        """設置系統資源限制"""
        if resource is None:
            # Windows或不支持resource的系統
            logger.warning("Resource limits not available on this platform")
            return

        try:
            # 設置內存限制
            resource.setrlimit(resource.RLIMIT_AS, (memory_mb * 1024 * 1024, memory_mb * 1024 * 1024))

            # 設置CPU時間限制
            resource.setrlimit(resource.RLIMIT_CPU, (int(timeout), int(timeout)))

            # 設置打開文件數限制
            resource.setrlimit(resource.RLIMIT_NOFILE, (100, 100))

            # 設置子進程數限制
            try:
                resource.setrlimit(resource.RLIMIT_NPROC, (1, 1))
            except (ValueError, OSError):
                # 在某些系統上可能不支持
                pass
        except Exception as e:
            logger.warning(f"Failed to set resource limits: {e}")


    def _create_safe_globals(self) -> Dict[str, Any]:
        """創建安全的全局環境"""
        # 導入內建函數
        safe_builtins = {
            'abs': abs,
            'min': min,
            'max': max,
            'sum': sum,
            'len': len,
            'range': range,
            'float': float,
            'int': int,
            'bool': bool,
            'str': str,
            'list': list,
            'dict': dict,
            'tuple': tuple,
            'set': set,
            'round': round,
            'sorted': sorted,
            'reversed': reversed,
            'enumerate': enumerate,
            'zip': zip,
            'map': map,
            'filter': filter,
        }

        safe_globals = {
            '__builtins__': safe_builtins,
        }

        # 安全的模組
        try:
            import pandas as pd
            safe_globals['pd'] = pd
        except ImportError:
            pass

        try:
            import numpy as np
            safe_globals['np'] = np
        except ImportError:
            pass

        return safe_globals

    def get_execution_stats(self) -> Dict[str, Any]:
        """獲取執行統計"""
        if not self.execution_history:
            return {'total_executions': 0}

        successful = sum(1 for r in self.execution_history if r['success'])
        failed = len(self.execution_history) - successful

        return {
            'total_executions': len(self.execution_history),
            'successful': successful,
            'failed': failed,
            'success_rate': (successful / len(self.execution_history)) * 100 if self.execution_history else 0,
            'avg_execution_time': sum(r['execution_time'] for r in self.execution_history) / len(self.execution_history),
            'recent_executions': self.execution_history[-10:]  # 最近10次
        }

    def clear_history(self):
        """清空執行歷史"""
        self.execution_history.clear()


class CodeMonitor:
    """代碼執行監控器"""

    def __init__(self):
        self.monitored_functions: Dict[str, Callable] = {}
        self.call_count: Dict[str, int] = {}
        self.performance_metrics: Dict[str, Dict[str, float]] = {}

    def register_function(
        self,
        name: str,
        func: Callable,
        max_calls: int = 1000
    ):
        """
        註冊需要監控的函數

        Args:
            name: 函數名稱
            func: 函數對象
            max_calls: 最大調用次數
        """
        self.monitored_functions[name] = {
            'func': func,
            'max_calls': max_calls
        }
        self.call_count[name] = 0
        self.performance_metrics[name] = {
            'total_time': 0,
            'avg_time': 0,
            'min_time': float('inf'),
            'max_time': 0
        }

    def monitor_execution(self, func_name: str, *args, **kwargs):
        """監控函數執行"""
        if func_name not in self.monitored_functions:
            return

        config = self.monitored_functions[func_name]

        # 檢查調用次數
        if self.call_count[func_name] >= config['max_calls']:
            raise ResourceExceededError(f"Function {func_name} exceeded max calls ({config['max_calls']})")

        # 記錄開始時間
        start_time = time.time()

        try:
            # 執行函數
            result = config['func'](*args, **kwargs)

            # 記錄性能指標
            exec_time = time.time() - start_time
            metrics = self.performance_metrics[func_name]

            metrics['total_time'] += exec_time
            metrics['min_time'] = min(metrics['min_time'], exec_time)
            metrics['max_time'] = max(metrics['max_time'], exec_time)
            metrics['avg_time'] = metrics['total_time'] / (self.call_count[func_name] + 1)

            # 增加調用計數
            self.call_count[func_name] += 1

            return result

        except Exception as e:
            logger.error(f"Error in monitored function {func_name}: {e}")
            raise

    def get_metrics(self, func_name: str) -> Optional[Dict[str, float]]:
        """獲取函數性能指標"""
        return self.performance_metrics.get(func_name)

    def get_all_metrics(self) -> Dict[str, Dict[str, float]]:
        """獲取所有函數性能指標"""
        return self.performance_metrics.copy()

    def reset_metrics(self, func_name: Optional[str] = None):
        """重置性能指標"""
        if func_name:
            if func_name in self.performance_metrics:
                self.performance_metrics[func_name] = {
                    'total_time': 0,
                    'avg_time': 0,
                    'min_time': float('inf'),
                    'max_time': 0
                }
                self.call_count[func_name] = 0
        else:
            # 重置所有
            for name in self.performance_metrics:
                self.performance_metrics[name] = {
                    'total_time': 0,
                    'avg_time': 0,
                    'min_time': float('inf'),
                    'max_time': 0
                }
                self.call_count[name] = 0


class SecurityScanner:
    """增強的安全掃描器"""

    def __init__(self):
        self.blocked_patterns = [
            r'\b__\w+__\b',  # 魔法方法
            r'\beval\s*\(',  # eval
            r'\bexec\s*\(',  # exec
            r'\bcompile\s*\(',  # compile
            r'\bopen\s*\(',  # open
            r'\bfile\s*\(',  # file
            r'\binput\s*\(',  # input
            r'\braw_input\s*\(',  # raw_input
            r'\b__import__\s*\(',  # __import__
            r'\breload\s*\(',  # reload
            r'\bhelp\s*\(',  # help
            r'\bquit\s*\(',  # quit
            r'\bexit\s*\(',  # exit
            r'\bglobals\s*\(',  # globals
            r'\blocals\s*\(',  # locals
            r'\bvars\s*\(',  # vars
            r'\bdir\s*\(',  # dir
            r'\bhasattr\s*\(',  # hasattr
            r'\bgetattr\s*\(',  # getattr
            r'\bsetattr\s*\(',  # setattr
            r'\bdelattr\s*\(',  # delattr
            r'\bimport\s+',  # import
            r'\bfrom\s+\w+\s+import',  # from ... import
            r'\bsubprocess',  # subprocess
            r'\bos\.system',  # os.system
            r'\bos\.popen',  # os.popen
            r'\bos\.exec',  # os.exec
            r'\bos\.fork',  # os.fork
            r'\bthreading',  # threading
            r'\bmultiprocessing',  # multiprocessing
            r'\basyncio',  # asyncio
            r'\btimeout_decorator',  # timeout
            r'\bsignal',  # signal
        ]

        self.warning_patterns = [
            r'\bwhile\s+True',  # 無限循環
            r'\bfor\s+.*\s+in\s+range\(\s*\d{7,}\s*\)',  # 大範圍循環
            r'\bdef\s+\w+\(.*\):\s*\n\s+.*\n\s+def',  # 嵌套函數定義
        ]

    def scan(self, code: str) -> Dict[str, Any]:
        """
        掃描代碼安全性

        Args:
            code: 待掃描代碼

        Returns:
            掃描結果
        """
        import re

        violations = []
        warnings = []

        # 檢查阻斷模式
        for pattern in self.blocked_patterns:
            matches = re.finditer(pattern, code, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                violations.append({
                    'type': 'blocked',
                    'pattern': pattern,
                    'match': match.group(),
                    'position': match.span()
                })

        # 檢查警告模式
        for pattern in self.warning_patterns:
            matches = re.finditer(pattern, code, re.IGNORECASE | re.MULTILINE)
            for match in matches:
                warnings.append({
                    'type': 'warning',
                    'pattern': pattern,
                    'match': match.group(),
                    'position': match.span()
                })

        # 計算風險評分
        risk_score = min(len(violations) * 20 + len(warnings) * 5, 100)

        return {
            'safe': len(violations) == 0,
            'risk_score': risk_score,
            'violations': violations,
            'warnings': warnings,
            'summary': {
                'total_violations': len(violations),
                'total_warnings': len(warnings)
            }
        }


# 導出
__all__ = [
    'SecureSandbox',
    'ResourceLimits',
    'TimeoutError',
    'ResourceExceededError',
    'CodeMonitor',
    'SecurityScanner',
]
