"""Core data models for the quantitative trading system.

This module defines the fundamental data structures used throughout the system,
including OHLCV price data, trading signals, and indicator configurations.
"""

from dataclasses import dataclass
from datetime import datetime
from enum import Enum
from typing import Dict, List, Optional, Union
import pandas as pd


class SignalType(Enum):
    """Trading signal types."""
    BUY = "BUY"
    SELL = "SELL"
    HOLD = "HOLD"


class PositionType(Enum):
    """Position types."""
    LONG = "LONG"
    SHORT = "SHORT"
    FLAT = "FLAT"


@dataclass
class OHLCV:
    """Open-High-Low-Close-Volume data structure.
    
    Represents a single candle/bar of price data with volume.
    All prices are in the same currency and volume is in shares/units.
    """
    timestamp: datetime
    open: float
    high: float
    low: float
    close: float
    volume: int
    
    def is_valid(self) -> bool:
        """Validate OHLCV data.
        
        Returns:
            bool: True if data is valid, False otherwise
        """
        return (
            self.high >= max(self.open, self.close, self.low) and
            self.low <= min(self.open, self.close, self.high) and
            self.open >= 0 and
            self.high >= self.open and
            self.low >= 0 and
            self.volume >= 0
        )
    
    def to_dict(self) -> Dict[str, Union[datetime, float, int]]:
        """Convert to dictionary.
        
        Returns:
            Dict containing OHLCV data
        """
        return {
            'timestamp': self.timestamp,
            'open': self.open,
            'high': self.high,
            'low': self.low,
            'close': self.close,
            'volume': self.volume
        }


@dataclass
class Signal:
    """Trading signal generated by a strategy.
    
    Represents a recommendation to buy, sell, or hold a position.
    """
    timestamp: datetime
    symbol: str
    signal_type: SignalType
    price: float
    confidence: float  # 0.0 to 1.0
    metadata: Optional[Dict] = None
    position: Optional[PositionType] = None
    
    def __post_init__(self):
        """Validate signal after initialization."""
        if not 0.0 <= self.confidence <= 1.0:
            raise ValueError("Confidence must be between 0.0 and 1.0")
        if self.price <= 0:
            raise ValueError("Price must be positive")
    
    @classmethod
    def from_ohlcv(cls, ohlcv: OHLCV, signal_type: SignalType, 
                   confidence: float, **kwargs) -> 'Signal':
        """Create signal from OHLCV data.
        
        Args:
            ohlcv: Source OHLCV data
            signal_type: Type of signal
            confidence: Signal confidence level
            **kwargs: Additional metadata
            
        Returns:
            Signal instance
        """
        return cls(
            timestamp=ohlcv.timestamp,
            symbol="",  # To be filled by strategy
            signal_type=signal_type,
            price=ohlcv.close,
            confidence=confidence,
            metadata=kwargs
        )


@dataclass
class IndicatorConfig:
    """Configuration for technical indicators.
    
    Stores parameters and settings for technical indicators.
    """
    name: str
    parameters: Dict[str, Union[int, float, str]]
    enabled: bool = True
    description: Optional[str] = None
    
    def __post_init__(self):
        """Validate configuration."""
        if not self.name:
            raise ValueError("Indicator name cannot be empty")
        if not self.parameters:
            self.parameters = {}
    
    def get_param(self, key: str, default=None):
        """Get parameter value.
        
        Args:
            key: Parameter key
            default: Default value if key not found
            
        Returns:
            Parameter value or default
        """
        return self.parameters.get(key, default)
    
    def set_param(self, key: str, value: Union[int, float, str]):
        """Set parameter value.
        
        Args:
            key: Parameter key
            value: Parameter value
        """
        self.parameters[key] = value


@dataclass
class BacktestConfig:
    """Configuration for backtest execution.
    
    Stores all parameters needed to run a backtest.
    """
    initial_capital: float
    commission: float = 0.001  # 0.1% default
    slippage: float = 0.0005   # 0.05% default
    start_date: Optional[datetime] = None
    end_date: Optional[datetime] = None
    benchmark: Optional[str] = None
    indicators: List[IndicatorConfig] = None
    
    def __post_init__(self):
        """Validate configuration."""
        if self.initial_capital <= 0:
            raise ValueError("Initial capital must be positive")
        if not 0 <= self.commission < 1:
            raise ValueError("Commission must be between 0 and 1")
        if not 0 <= self.slippage < 1:
            raise ValueError("Slippage must be between 0 and 1")


@dataclass
class Position:
    """Represents a trading position.
    
    Tracks current position in a symbol.
    """
    symbol: str
    size: float
    entry_price: float
    current_price: float
    timestamp: datetime
    unrealized_pnl: float = 0.0
    realized_pnl: float = 0.0
    
    @property
    def value(self) -> float:
        """Position market value."""
        return self.size * self.current_price
    
    @property
    def pnl(self) -> float:
        """Total P&L (realized + unrealized)."""
        return self.realized_pnl + self.unrealized_pnl
    
    def update(self, new_price: float):
        """Update position with new price.
        
        Args:
            new_price: Current market price
        """
        self.current_price = new_price
        self.unrealized_pnl = (new_price - self.entry_price) * self.size


@dataclass
class Trade:
    """Represents a completed trade.
    
    Records all details of a completed transaction.
    """
    id: str
    symbol: str
    side: str  # BUY or SELL
    size: float
    price: float
    timestamp: datetime
    commission: float
    pnl: float = 0.0
    
    @property
    def value(self) -> float:
        """Trade notional value."""
        return self.size * self.price
    
    @property
    def net_value(self) -> float:
        """Trade value minus commission."""
        return self.value - self.commission


def dataframe_to_ohlcv(df: pd.DataFrame) -> List[OHLCV]:
    """Convert pandas DataFrame to OHLCV list.
    
    Expected DataFrame columns: timestamp, open, high, low, close, volume
    
    Args:
        df: DataFrame with OHLCV data
        
    Returns:
        List of OHLCV objects
        
    Raises:
        ValueError: If DataFrame is missing required columns
    """
    required_cols = ['timestamp', 'open', 'high', 'low', 'close', 'volume']
    if not all(col in df.columns for col in required_cols):
        raise ValueError(f"DataFrame must contain columns: {required_cols}")
    
    ohlcv_list = []
    for _, row in df.iterrows():
        ohlcv = OHLCV(
            timestamp=row['timestamp'],
            open=float(row['open']),
            high=float(row['high']),
            low=float(row['low']),
            close=float(row['close']),
            volume=int(row['volume'])
        )
        if ohlcv.is_valid():
            ohlcv_list.append(ohlcv)
    
    return ohlcv_list


def ohlcv_to_dataframe(ohlcv_list: List[OHLCV]) -> pd.DataFrame:
    """Convert OHLCV list to pandas DataFrame.

    Args:
        ohlcv_list: List of OHLCV objects

    Returns:
        DataFrame with OHLCV data
    """
    data = [ohlcv.to_dict() for ohlcv in ohlcv_list]
    return pd.DataFrame(data)


# ============================================================================
# Phase 2: Pydantic v2 Data Models
# ============================================================================

from pydantic import BaseModel, Field, ConfigDict, field_validator
from uuid import UUID
from typing import Any
import json


class UserConfig(BaseModel):
    """用戶配置模型。

    存儲用戶個人偏好和默認設置。
    """

    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "user_id": "550e8400-e29b-41d4-a716-446655440000",
                "default_symbols": ["0700.HK", "0388.HK", "0939.HK"],
                "preferred_indicators": ["MA", "RSI", "MACD"],
                "theme": "dark",
                "auto_save": True
            }
        },
        str_strip_whitespace=True,
        validate_assignment=True
    )

    user_id: UUID = Field(
        ...,
        description="用戶唯一標識符 (UUID格式)"
    )
    default_symbols: List[str] = Field(
        default_factory=list,
        description="默認股票代碼列表",
        max_length=50
    )
    preferred_indicators: List[str] = Field(
        default_factory=list,
        description="首選技術指標列表",
        max_length=20
    )
    theme: str = Field(
        default="light",
        description="界面主題 (dark 或 light)"
    )
    auto_save: bool = Field(
        default=True,
        description="是否自動保存配置"
    )
    created_at: datetime = Field(
        default_factory=datetime.now,
        description="創建時間"
    )
    updated_at: datetime = Field(
        default_factory=datetime.now,
        description="最後更新時間"
    )

    @field_validator('theme')
    @classmethod
    def validate_theme(cls, v: str) -> str:
        """驗證主題值。

        Args:
            v: 主題值

        Returns:
            驗證後的主題值

        Raises:
            ValueError: 主題值不在允許範圍內
        """
        if v not in ['dark', 'light']:
            raise ValueError("theme must be either 'dark' or 'light'")
        return v

    @field_validator('default_symbols')
    @classmethod
    def validate_symbols(cls, v: List[str]) -> List[str]:
        """驗證股票代碼。

        Args:
            v: 股票代碼列表

        Returns:
            驗證後的代碼列表

        Raises:
            ValueError: 代碼格式或長度不符合要求
        """
        for symbol in v:
            if not isinstance(symbol, str) or len(symbol) < 5 or len(symbol) > 10:
                raise ValueError(
                    f"Symbol {symbol} must be 5-10 characters long"
                )
        return v

    @field_validator('preferred_indicators')
    @classmethod
    def validate_indicators(cls, v: List[str]) -> List[str]:
        """驗證技術指標。

        Args:
            v: 指標列表

        Returns:
            驗證後的指標列表

        Raises:
            ValueError: 指標名稱長度不符合要求
        """
        for indicator in v:
            if not isinstance(indicator, str) or len(indicator) < 2 or len(indicator) > 50:
                raise ValueError(
                    f"Indicator {indicator} must be 2-50 characters long"
                )
        return v

    def model_dump(self, **kwargs) -> Dict[str, Any]:
        """序列化為字典。

        覆蓋基類方法以處理UUID和datetime序列化。
        """
        data = super().model_dump(**kwargs)
        # 轉換UUID為字符串
        data['user_id'] = str(self.user_id)
        # 轉換datetime為ISO格式字符串
        data['created_at'] = self.created_at.isoformat()
        data['updated_at'] = self.updated_at.isoformat()
        return data

    def to_dict(self) -> Dict[str, Any]:
        """轉換為字典。

        Returns:
            包含配置數據的字典
        """
        return self.model_dump()

    def to_json(self) -> str:
        """轉換為JSON字符串。

        Returns:
            JSON格式的字符串
        """
        return self.model_dump_json()

    @classmethod
    def from_json(cls, json_str: str) -> 'UserConfig':
        """從JSON字符串創建實例。

        Args:
            json_str: JSON字符串

        Returns:
            UserConfig實例
        """
        return cls.model_validate_json(json_str)

    def update_timestamp(self) -> None:
        """更新時間戳。

        更新updated_at字段為當前時間。
        """
        self.updated_at = datetime.now()

    def add_symbol(self, symbol: str) -> None:
        """添加股票代碼。

        Args:
            symbol: 股票代碼
        """
        if symbol not in self.default_symbols:
            self.default_symbols.append(symbol)
            self.update_timestamp()

    def remove_symbol(self, symbol: str) -> None:
        """移除股票代碼。

        Args:
            symbol: 股票代碼
        """
        if symbol in self.default_symbols:
            self.default_symbols.remove(symbol)
            self.update_timestamp()

    def add_indicator(self, indicator: str) -> None:
        """添加技術指標。

        Args:
            indicator: 技術指標名稱
        """
        if indicator not in self.preferred_indicators:
            self.preferred_indicators.append(indicator)
            self.update_timestamp()

    def remove_indicator(self, indicator: str) -> None:
        """移除技術指標。

        Args:
            indicator: 技術指標名稱
        """
        if indicator in self.preferred_indicators:
            self.preferred_indicators.remove(indicator)
            self.update_timestamp()
