//! Report generation
//!
//! This module generates Markdown and JSON reports from backtest results.

use crate::core::data::BacktestResult;
use crate::core::error::BacktestError;
use serde_json::json;
use std::fs::File;
use std::path::Path;

/// Report bundle with multiple formats
#[derive(Debug)]
pub struct ReportBundle {
    pub markdown_path: Option<std::path::PathBuf>,
    pub json_path: Option<std::path::PathBuf>,
    pub metrics_json: serde_json::Value,
}

/// Generate Markdown report
pub fn generate_markdown(
    result: &BacktestResult,
    output_path: &Path,
) -> Result<(), BacktestError> {
    let mut file = File::create(output_path)
        .map_err(|e| BacktestError::io_error(&format!("Failed to create file: {}", e)))?;

    let content = format!(
        "# Backtest Report

## Summary
- **Symbol**: {symbol}
- **Period**: {start_date} to {end_date}
- **Initial Capital**: ${initial_capital:.2}
- **Final Value**: ${final_value:.2}

## Performance Metrics

| Metric | Value |
|--------|-------|
| Total Return | {total_return:.2}% |
| Annual Return | {annual_return:.2}% |
| Sharpe Ratio | {sharpe:.2} |
| Max Drawdown | {max_drawdown:.2}% |
| Win Rate | {win_rate:.1}% |
| Total Trades | {total_trades} |
| Winning Trades | {winning_trades} |
| Losing Trades | {losing_trades} |

## Trade History

{trade_table}

## Equity Curve

{equity_curve}

---
*Generated by Rust Non-Price Data Technical Indicators System*",
        symbol = result.symbol,
        start_date = result.start_date,
        end_date = result.end_date,
        initial_capital = result.initial_capital,
        final_value = result.final_value,
        total_return = result.total_return_pct,
        annual_return = result.annual_return_pct,
        sharpe = result.sharpe_ratio,
        max_drawdown = result.max_drawdown_pct,
        win_rate = result.win_rate_pct,
        total_trades = result.total_trades,
        winning_trades = result.winning_trades,
        losing_trades = result.losing_trades,
        trade_table = format_trades_table(&result.trades),
        equity_curve = format_equity_curve(&result.equity_curve),
    );

    use std::io::Write;
    file.write_all(content.as_bytes())
        .map_err(|e| BacktestError::io_error(&format!("Failed to write file: {}", e)))?;

    Ok(())
}

/// Generate JSON report
pub fn generate_json(
    result: &BacktestResult,
    output_path: &Path,
) -> Result<(), BacktestError> {
    let json_value = json!({
        "id": result.id,
        "symbol": result.symbol,
        "period": {
            "start": result.start_date.to_string(),
            "end": result.end_date.to_string()
        },
        "initial_capital": result.initial_capital,
        "final_value": result.final_value,
        "metrics": {
            "total_return_pct": result.total_return_pct,
            "annual_return_pct": result.annual_return_pct,
            "sharpe_ratio": result.sharpe_ratio,
            "max_drawdown_pct": result.max_drawdown_pct,
            "win_rate_pct": result.win_rate_pct,
            "total_trades": result.total_trades,
            "winning_trades": result.winning_trades,
            "losing_trades": result.losing_trades
        },
        "parameters": {
            "zscore_buy": result.parameters.zscore_buy,
            "zscore_sell": result.parameters.zscore_sell,
            "rsi_buy": result.parameters.rsi_buy,
            "rsi_sell": result.parameters.rsi_sell,
            "sma_fast": result.parameters.sma_fast,
            "sma_slow": result.parameters.sma_slow
        },
        "trades": result.trades,
        "equity_curve": result.equity_curve
    });

    let file = File::create(output_path)
        .map_err(|e| BacktestError::io_error(&format!("Failed to create file: {}", e)))?;

    serde_json::to_writer_pretty(file, &json_value)
        .map_err(|e| BacktestError::json_error(&e.to_string()))?;

    Ok(())
}

/// Generate comprehensive report (Markdown + JSON)
pub fn generate_comprehensive(
    result: &BacktestResult,
    output_dir: &Path,
) -> Result<ReportBundle, BacktestError> {
    // Create directory if it doesn't exist
    std::fs::create_dir_all(output_dir)
        .map_err(|e| BacktestError::io_error(&format!("Failed to create directory: {}", e)))?;

    // Generate Markdown report
    let markdown_path = output_dir.join("backtest_report.md");
    generate_markdown(result, &markdown_path)?;

    // Generate JSON report
    let json_path = output_dir.join("backtest_report.json");
    generate_json(result, &json_path)?;

    // Create metrics JSON
    let metrics_json = json!({
        "summary": {
            "total_return": result.total_return_pct,
            "sharpe_ratio": result.sharpe_ratio,
            "max_drawdown": result.max_drawdown_pct,
            "win_rate": result.win_rate_pct
        },
        "trades": {
            "total": result.total_trades,
            "winning": result.winning_trades,
            "losing": result.losing_trades
        }
    });

    Ok(ReportBundle {
        markdown_path: Some(markdown_path),
        json_path: Some(json_path),
        metrics_json,
    })
}

/// Format trades table for Markdown
fn format_trades_table(trades: &[crate::core::data::Trade]) -> String {
    if trades.is_empty() {
        "No trades executed.".to_string()
    } else {
        let mut table = String::new();
        table.push_str("| Date | Action | Entry Price | Exit Price | P&L |\n");
        table.push_str("|------|--------|-------------|------------|-----|\n");

        for trade in trades {
            table.push_str(&format!(
                "| {} | {} | ${:.2} | ${:.2} | ${:.2} |\n",
                trade.entry_date,
                trade.entry_signal,
                trade.entry_price,
                trade.exit_price,
                trade.pnl
            ));
        }

        table
    }
}

/// Format equity curve for Markdown
fn format_equity_curve(equity_curve: &[(chrono::NaiveDate, f64)]) -> String {
    if equity_curve.is_empty() {
        "No equity curve data.".to_string()
    } else {
        let mut curve = String::new();
        curve.push_str("| Date | Portfolio Value |\n");
        curve.push_str("|------|----------------|\n");

        for (date, value) in equity_curve.iter().take(10) {
            curve.push_str(&format!("| {} | ${:.2} |\n", date, value));
        }

        if equity_curve.len() > 10 {
            curve.push_str(&format!("| ... | ({} more data points) |\n", equity_curve.len() - 10));
        }

        curve
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use chrono::NaiveDate;
    use tempfile::tempdir;

    #[test]
    fn test_generate_markdown() {
        let result = BacktestResult::new(
            "test".to_string(),
            "TEST".to_string(),
            NaiveDate::from_ymd_opt(2023, 1, 1).unwrap(),
            NaiveDate::from_ymd_opt(2023, 12, 31).unwrap(),
            100000.0,
            crate::core::data::ParameterSet::default(),
        );

        let temp_dir = tempdir().unwrap();
        let path = temp_dir.path().join("test_report.md");

        let result = generate_markdown(&result, &path);
        assert!(result.is_ok());
    }

    #[test]
    fn test_generate_json() {
        let result = BacktestResult::new(
            "test".to_string(),
            "TEST".to_string(),
            NaiveDate::from_ymd_opt(2023, 1, 1).unwrap(),
            NaiveDate::from_ymd_opt(2023, 12, 31).unwrap(),
            100000.0,
            crate::core::data::ParameterSet::default(),
        );

        let temp_dir = tempdir().unwrap();
        let path = temp_dir.path().join("test_report.json");

        let result = generate_json(&result, &path);
        assert!(result.is_ok());
    }
}
